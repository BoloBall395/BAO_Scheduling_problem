# -*- coding: utf-8 -*-
"""ProyectoBAO.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1seNA4prVzChRYeMohyS4-RQByaivAN_b
"""

import xml.etree.ElementTree as ET
import pandas as pd
import numpy as np
import random
import math
!pip install inspyred

"""# Crear tablas a partir de xml

**Getters Methods Crear Tablas**
"""

def getLocation(rango_columna_location):
  return str(np.random.randint(rango_columna_location[0], rango_columna_location[1])) + "," + str(np.random.randint(rango_columna_location[0], rango_columna_location[1]))

def getInstructor(rango_columna_instructor):
  return np.random.randint(rango_columna_instructor[0], rango_columna_instructor[1])

def getRoomId(cantidad_room_id, probabilidad_room_id, rooms_list):
  devolver = []
  listaAux = rooms_list.copy()
  aux = np.random.choice(cantidad_room_id,  p=probabilidad_room_id)
  for i in range(aux):
    elem = random.choice(listaAux)
    devolver.append(elem)
    listaAux.remove(elem)
  return devolver

def getDays(cantidad_dias , probabilidad_dias):
  return np.random.choice(cantidad_dias , p=probabilidad_dias)

def getLength(cantidad_length , probabilidad_length):
  return np.random.choice(cantidad_length , p=probabilidad_length)

"""**Aulas**"""

# Definir el tamaño de la matriz + Definir Elems
num_aulas = 20
num_attrib_aulas = 2

# Definir los rangos para cada atributo
rango_columna_id = (1, 20)
rango_columna_location = (0, 50)

# Generar la matriz con números aleatorios en los rangos especificados para cada columna
matriz = np.empty((num_aulas, num_attrib_aulas), dtype=object)
for i in range(num_aulas):
    matriz[i, 0] = i+1
    matriz[i, 1] = getLocation(rango_columna_location)

# Visualizar y asignar tabla
nombres_columnas = ['id', 'location']
rooms = pd.DataFrame(matriz, columns=nombres_columnas)
print("Matriz Pandas generada:")
rooms

"""**Asignaturas**"""

# Definir el tamaño de la matriz + Definir Elems
num_asignaturas = 100
num_attrib_asignaturas = 5

propabilidad_room_id=[0.5,0.3,0.2]
cantidad_room_id=[1,2,3] #en cuántas aulas puede darse cada asignatura
rooms_list = list(range(1, 21)) #también podría ser entre 0 y 130 //este range hace que no sean en total 131 elementos
probabilidad_dias=[0.1,0.6,0.3]
cantidad_dias=[1,2,3]
probabilidad_length=[0.2,0.1,0.5,0.2]
cantidad_length=[1,1.5,2,3]

# Definir los rangos para cada atributo
rango_columna_id = (1, 100)
rango_columna_instructor = (1, 20)
rango_columna_room_id = (1, 20)

##ESTAS CREO NO SIRVEN
#rango_columna_days = (1, 3)
#rango_columna_length = (1, 3)

# Generar la matriz con números aleatorios en los rangos especificados para cada columna
matriz = np.empty((num_asignaturas, num_attrib_asignaturas), dtype=object)
for i in range(num_asignaturas):
    matriz[i, 0] = i+1
    matriz[i, 1] = getInstructor(rango_columna_instructor)
    matriz[i, 2] = getRoomId(cantidad_room_id, propabilidad_room_id, rooms_list)
    matriz[i, 3] = getDays(cantidad_dias , probabilidad_dias)
    matriz[i, 4] = getLength(cantidad_length , probabilidad_length)

# Visualizar y asignar tabla
nombres_columnas = ['id', 'instructor', "room_id", "days", "length"]
classes = pd.DataFrame(matriz, columns=nombres_columnas)
print("Matriz Pandas generada:")
classes

"""**Estudiantes**"""

idEstudiantes = [i+1 for i in range(145)]
TablaEstudiantes = []

# for j in range(145):
#     numAL=random.choice(idEstudiantes)
#     idEstudiantes.remove(numAL)
#     TablaEstudiantes.append(numAL)

arrayClases = [[] for i in range(145)]

for k in range(145):
    idAsignaturas = [i+1 for i in range(100)]
    numAL=random.randint(1,5)
    for i in range(numAL):
        numAUX=random.choice(idAsignaturas)
        idAsignaturas.remove(numAUX)
        arrayClases[k].append(numAUX)


df_students = pd.DataFrame({'id': idEstudiantes})
df_classes = pd.DataFrame({'classes': arrayClases})
students = pd.concat([df_students, df_classes], axis=1)
students

"""**Profesores**"""

idProfes = [i+1 for i in range(20)]
TablaProfes = []
# for j in range (20):
#   numAL=random.choice(idProfes)
#   idProfes.remove(numAL)
#   TablaProfes.append(numAL)

df=pd.DataFrame(idProfes)
instructors = df.rename(columns={0:'instructor'})
instructors

"""# Generar individuo"""

def generarHoras():
  matriz=[[0] for i in range(len(classes))]
  horas=[]
  for fila1,fila2 in zip(matriz,matriz):
    filas=fila1+fila2
    horas.append(filas)
  return horas
def generarAulas():
  aulas=[0]*len(classes)
  return aulas
def generarProfes():
  profes=[0]*len(classes)
  return profes

def rellenarDatos(individuoVacio):
  individuoH=rellenarHoras(individuoVacio)
  individuoHA=rellenarAulas(individuoH)
  individuo=rellenarProfes(individuoHA)
  return individuo

def rellenarHoras(individuoVacio):
  i=0
  for index, clase in classes.iterrows():
    numDias=clase["days"]
    horas=clase["length"]
    dias="00000"
    listaDias=[0,1,2,3,4]
    for j in range(numDias):
      dia=random.choice(listaDias)
      dias=dias[:dia]+"1"+dias[dia+1:]
      listaDias.remove(dia)
    inicio=random.randint(0,23-((horas*2)-1))
    individuoVacio[0][i][0]=dias
    individuoVacio[0][i][1]=inicio
    i+=1
  return individuoVacio

def rellenarAulas(individuoH):
  i=0
  for index, clase in classes.iterrows():
    aula=clase["room_id"]
    if len(aula)==1:
      individuoH[1][i]=aula[0]
    elif len(aula)==0:
      room=random.randint(0,len(rooms)-1)
      individuoH[1][i]=rooms.loc[room,"id"]
    elif len(aula)>1:
      room=random.choice(aula)
      individuoH[1][i]=room
    i+=1
  return individuoH

def rellenarProfes(individuoHA):
  i=0
  for index, clase in classes.iterrows():
    profe=clase["instructor"]
    if profe!=0:
      individuoHA[2][i]=profe
    else:
      profeRandom=random.randint(0,len(instructors)-1)
      individuoHA[2][i]=instructors.loc[profeRandom,"instructor"]
    i+=1
  return individuoHA

def generarVacio():
  individuo=[]
  horas=generarHoras()
  aulas=generarAulas()
  profes=generarProfes()
  individuo.append(horas)
  individuo.append(aulas)
  individuo.append(profes)
  return individuo

def generator(random,args):
  individuoVacio=generarVacio()
  individuo=rellenarDatos(individuoVacio)
  return individuo

"""# Crossover"""

import inspyred.ec.variators
from inspyred.ec.variators.crossovers import crossover
@crossover
def custom_crossover(random,parent1,parent2,args):
  child1,child2=parent1.copy(),parent2.copy()
  children=[]
  if random.random()<args.setdefault("crossover_rate",1.0):
    child1[0],child2[0]=one_point_crossover(random,parent1[0],parent2[0])
    child1[1],child2[1]=crossover_uniform(random,parent1[1],parent2[1])
    child1[2],child2[2]=crossover_uniform(random,parent1[2],parent2[2])
  children.append(child1)
  children.append(child2)
  return children
def crossover_uniform(random,table1,table2):
  mask=generarMask()
  for i in range(len(classes)):
    if(mask==1):
      table1[i],table2[i]=table2[i],table1[i]
  return table1,table2
def generarMask():
  mask=[]
  for i in range(len(classes)):
    numero=random.randint(0,1)
    mask.append(numero)
  return mask
def one_point_crossover(random,table1, table2):
  crossover_point = random.randint(1, len(table1) - 1)
  new_table1 = table1[:crossover_point] + table2[crossover_point:]
  new_table2 = table2[:crossover_point] + table1[crossover_point:]
  return new_table1, new_table2

import inspyred.ec.variators
from inspyred.ec.variators.mutators import mutator
@mutator
def custom_mutation(random,candidate,args):
  if random.random()<args.setdefault('mutation_rate', 0.1):
   candidate=mutarHoras(random,candidate,args)
   candidate=mutarAulas(random,candidate,args)
   candidate=mutarProfes(random,candidate,args)
  return candidate
def mutarHoras(random,candidate,args):
  for index, clase in classes.iterrows():
     numDias=clase["days"]
     horas=clase["length"]
     dias="00000"
     listaDias=[0,1,2,3,4]
     for j in range(numDias):
       dia=random.choice(listaDias)
       dias=dias[:dia]+"1"+dias[dia+1:]
       listaDias.remove(dia)
     inicio=random.randint(0,23-((horas*2)-1))
     candidate[0][index][0]=dias
     candidate[0][index][1]=inicio
  return candidate
def mutarAulas(random,candidate,args):
  for index, clase in classes.iterrows():
      aulas=classes["room_id"]
      if len(aulas)>1:
        room=random.choice(aulas)
        if len(room)>0:
          candidate[1][index]=room[0]
      elif len(aulas)==0:
        room=random.randint(0,len(rooms)-1)
        candidate[1][index]=rooms.loc[room,"id"].iloc[0]
  return candidate
def mutarProfes(random,candidate,args):
  for index, clase in classes.iterrows():
      profe=clase["instructor"]
      if profe==0:
       profeRandom=random.randint(0,len(instructors)-1)
       candidate[2][index]=instructors.loc[profeRandom,"instructor"]
  return candidate

"""# Generar horario para constraints"""

def generarHorarioVacio():
  aulas=[]
  for i in range(rooms.shape[0]):
    matriz = [[[] for _ in range(24)] for _ in range(5)]
    aulas.append(matriz)
  instructores=[[] for _ in range(len(instructors))]
  individuo=[aulas,instructores]
  return individuo

def rellenarHorario(horario,iT):
  i=0
  for index, clase in classes.iterrows():
    dias=iT[0][i][0]
    hora=iT[0][i][1]
    aula=iT[1][i]
    profe=iT[2][i]
    duracion=clase["length"]
    fila_rooms = rooms.index[rooms['id'] == aula].tolist()
    for j in range(5):
      for k in range(int(duracion*2)):
        if dias[j]=="1":
          horario[0][fila_rooms[0]][j][hora+k].append(clase["id"])
    fila_profe=instructors.index[instructors["instructor"]==profe].tolist()
    horario[1][fila_profe[0]].append(clase["id"])
    i+=1
  return horario

"""# Constraints

## Hard constraints
"""

def dosClasesALaVezEnUnAula(individual):
  individualT=transformarIndividuo(individual)
  total=0
  for i in range(len(individualT[0])):
    for j in range(5):
      for k in range(24):
        clases=individualT[0][i][j][k]
        if(len(clases)>1):
          total+=1
  return total
def dosClasesALaVezEnUnAula_Norm(x):
  totalIncumple=dosClasesALaVezEnUnAula(x)
  if totalIncumple<100:
    return totalIncumple/100
  else:
    return 1
def profeDosClasesALaVez(individual):
 total=0
 profeComprobado=False
 individualT = transformarIndividuo(individual)
 for i, asignaturas in enumerate(individualT[1]):
  dias = []
  horas = []
  for asignatura in asignaturas:
   fila = classes[classes["id"] == asignatura].index.tolist()
   dias.append(individual[0][fila[0]][0])
   horas.append(individual[0][fila[0]][1])
   for a, dia_a in enumerate(dias):
    for b, dia_b in enumerate(dias):
     if a != b:
      for l in range(5):
       if dia_a[l] == dia_b[l] == "1":
        fila_clase1 = classes[classes['id'] == asignaturas[a]].index.tolist()
        fila_clase2 = classes[classes['id'] == asignaturas[b]].index.tolist()
        length1 = classes.loc[fila_clase1, "length"].iloc[0]
        length2 = classes.loc[fila_clase2, "length"].iloc[0]
        horas1 = horas[a]
        horas2 = horas[b]
        if ((horas1 >= horas2) and (horas1 <= (horas2 + length2 * 2))) or ((horas2 >= horas1) and (horas2 <= (horas1 + length1 * 2))):
          total+=1
          profeComprobado=True
        if profeComprobado:
          break
      if profeComprobado:
        break
    if profeComprobado:
      break
   if profeComprobado:
    break
  profeComprobado=False
 return total/len(individualT[1])
def estudianteDosClasesALaVez(individual):
  incumple=False
  estudianteComprobado=False
  i=0
  total=0
  for index, student in students.iterrows():
    asignaturas=student["classes"]
    dias=[]
    horas=[]
    for j in range(len(asignaturas)):
      fila=classes.index[classes["id"]==asignaturas[j]].tolist()
      dias.append(individual[0][fila[0]][0])
      horas.append(individual[0][fila[0]][1])
    for a in range(len(dias)):
      asignatura=dias[a]
      for b in range(len(dias)):
        asignatura2=dias[b]
        for l in range(5):
          if a!=b and asignatura[l]==asignatura2[l]=="1":
            fila_clase1=classes.index[classes['id'] == asignaturas[a]].tolist()
            fila_clase2=classes.index[classes['id'] == asignaturas[b]].tolist()
            length1=classes.loc[fila_clase1,"length"].iloc[0]
            length2=classes.loc[fila_clase2,"length"].iloc[0]
            horas1=horas[a]
            horas2=horas[b]
            if ((horas1>=horas2)and(horas1<=(horas2+length2*2)))or((horas2>=horas1)and(horas2<=(horas1+length1*2))):
              total+=1
              estudianteComprobado=True
          if estudianteComprobado:
            break
        if estudianteComprobado:
          break
      if estudianteComprobado:
        break
    estudianteComprobado=False
  return total/len(students)

def transformarIndividuo(iT):
  individuoTransformado=generarHorarioVacio()
  individuoTransformado=rellenarHorario(individuoTransformado,iT)
  return individuoTransformado

"""## Soft constraints"""

def clasesDosDiasSeguidos(individual):
  totalIncumple=0
  for i in range(len(individual[0])):
    dias=individual[0][i][0]
    seguidos=0
    for j in range(5):
      if dias[j]=="1":
        seguidos+=1
      elif dias[j]=="0":
        seguidos=0
      if seguidos>1:
        totalIncumple+=1
        break
  return totalIncumple
def clasesDosDiasSeguidos_Norm(individual):
  total=clasesDosDiasSeguidos(individual)
  return total/len(classes)

def numHuecosEnHorario(x):
  huecosPorAula=[]
  xT=transformarIndividuo(x)
  for i in range(len(xT[0])):
    huecosPorDia=[]
    for j in range(5):
      huecos=0
      hayClase=False
      huecoPotencial=False
      for k in range(24):
        if not hayClase:
          if len(xT[0][i][j][k])>0:
            hayClase=True
        else:
          if not huecoPotencial:
            if len(xT[0][i][j][k])==0:
              huecoPotencial=True
          else:
            if len(xT[0][i][j][k])>0:
              huecos+=1
              hayClase=False
              huecoPotencial=False
      huecosPorDia.append(huecos)
    suma=sum(huecosPorDia)
    huecosPorAula.append(suma)
  sumaTotal=sum(huecosPorAula)
  return sumaTotal/len(huecosPorAula)
def numHuecosEnHorario_Norm(x):
  resultado=numHuecosEnHorario(x)
  if resultado<=5:
    return resultado/5
  else:
    return 1

def comprobarMetrosRecorridosDia_CambiosDeClase_NumHuecosEstudiantes(x):
  mediaDistanciasEstudiantePorSemana=[]
  mediaCambiosEstudiantePorSemana=[]
  mediaHuecosPorEstudiante=[]
  mediaCambios=0
  for index, student in students.iterrows():
    asignaturas=student["classes"]
    distanciasPorDia=[]
    cambiosPorDia=[]
    huecosPorDia=[]
    for j in range(5):
      horas=[]
      duracion=[]
      localizacion=[]
      aulas=[]
      distancia=0
      huecos=0
      for asignatura in asignaturas:
         fila_clase=classes.index[classes['id'] == asignatura].tolist()
         dias=x[0][fila_clase[0]][0]
         if dias[j]=="1":
           horas.append(x[0][fila_clase[0]][1])
           duracion.append(classes.loc[fila_clase[0]]["length"])
           room=x[1][fila_clase[0]]
           aulas.append(room)
           room_index=rooms.index[rooms["id"]==room].tolist()
           localizacion.append(rooms.loc[room_index]["location"].iloc[0])
      if len(horas)>1:
        ordenado = sorted(zip(horas, localizacion,duracion), key=lambda x: x[0])
        #por cada asignatura en las asignaturas ordenadas por horas
        for k in range(len(ordenado)-1):
          x1, y1 = map(float, ordenado[k][1].split(","))
          x2, y2 = map(float, ordenado[k + 1][1].split(","))
          distancia+=math.sqrt((x2-x1)**2 + (y2-y1)**2)
          if (int(ordenado[k+1][0])-(int(ordenado[k][0])+ordenado[k][2] * 2)) > 1:
           huecos+=1
      distanciasPorDia.append(distancia)
      cambiosPorDia.append(len(set(aulas)))
      huecosPorDia.append(huecos)
    mediaDistanciasEstudiantePorSemana.append(np.mean(distanciasPorDia))
    mediaCambiosEstudiantePorSemana.append(np.mean(cambiosPorDia))
    mediaHuecosPorEstudiante.append(np.mean(huecosPorDia))
  mediaCambios=np.mean(mediaCambiosEstudiantePorSemana)
  mediaDistancia=np.mean(mediaDistanciasEstudiantePorSemana)
  mediaHuecos=np.mean(mediaHuecosPorEstudiante)
  return mediaDistancia,mediaCambios,mediaHuecos
def comprobarMetrosRecorridosDia_CambiosDeClase_NumHuecosEstudiante_Norm(x):
  distancia,cambios,huecos=comprobarMetrosRecorridosDia_CambiosDeClase_NumHuecosEstudiantes(x)
  if distancia<=20:
    a=distancia/20
  else:
    a=1
  if cambios<=3:
    b=cambios/3
  else:
    b=1
  if huecos<=0.05:
    c=0
  elif huecos>=0.1  and huecos<0.15:
    c=0.2
  elif huecos>=0.15  and huecos<0.2:
    c=0.4
  elif huecos>=0.2  and huecos<0.25:
    c=0.6
  elif huecos>=0.25  and huecos<0.3:
    c=0.8
  else:
    c=1
  return a,b,c

"""#Fitness function"""

def fitness_static_penalty(candidates,args):
  fitness=[]
  hard=0
  for c in candidates:
    h1=dosClasesALaVezEnUnAula_Norm(c)
    h2=profeDosClasesALaVez(c)
    h3=estudianteDosClasesALaVez(c)
    hard=0.21*h1+0.28*h2+0.3*h3
    dist,camb,huecos=comprobarMetrosRecorridosDia_CambiosDeClase_NumHuecosEstudiante_Norm(c)
    fit=hard+0.06*clasesDosDiasSeguidos_Norm(c)+0.7*numHuecosEnHorario_Norm(c)+0.7*huecos+0.5*dist+0.5*camb
    fitness.append(fit)
  return fitness

"""# GA"""

!pip install inspyred
from inspyred import ec
from inspyred import benchmarks
from inspyred.ec import emo
import numpy as np
import time

def test_scheduling_ga(method):
  rng=random.Random()
  ea=ec.GA(rng)
  ea.selector=ec.selectors.tournament_selection
  ea.replacer=ec.replacers.generational_replacement
  ea.variator=[custom_crossover,custom_mutation]
  ea.terminator=ec.terminators.generation_termination
  ea.observer=ec.observers.stats_observer
  final_pop=ea.evolve(generator=generator,
                      evaluator=method,
                      pop_size=5,
                      maximize=False,
                      tournament_size=4,
                      max_generations=100,
                      crossover_rate=1,
                      mutation_rate=0.15)
  return final_pop

a=test_scheduling_ga(fitness_static_penalty)

print(a)

"""#ACO"""

import numpy as np
from copy import deepcopy
from typing import List, Dict
class ScheduleProblem:
  def __init__(self,asignaturas,duraciones,aulas,aulasAsignadas,dias,profesClases,n_ants: int=10,alpha:float=1,beta:float=5,rho:float=0.8):
    self.asig=asignaturas
    self.lengths=duraciones
    self.clases=aulas
    self.asignadas=aulasAsignadas
    self.diasAsig=dias
    self.profesAsig=profesClases
    self.n_ants = n_ants
    self.alpha = alpha
    self.beta = beta
    self.rho = rho
    self.pheromonesAsig=None
    self.pheromonesAula=None
    self.pheromonesDia=None
    self.pheromonesHora=None
    self.pheromonesProfe=None
    self.best_solution = None
    self.best_fitness = None
    self.pheromone_history = []
    self.trails_history = []
    self.best_fitness_history = []
  def optimize(self,max_evaluations:int=1000):
    self._initialize()
    n_evaluations=0
    iter_fitness=1e10
    while n_evaluations<max_evaluations:
      trails=[]
      for _ in range(self.n_ants):
        solution = self._construct_solution()
        fitness = self._evaluate(solution)
        n_evaluations += 1
        trails.append((solution, fitness))
        if fitness < self.best_fitness:
          self.best_solution = solution
          self.best_fitness = fitness
        self._update_pheromone(trails, iter_fitness)
        iter_fitness = self.best_fitness
        self.trails_history.append(deepcopy(trails))
        self.best_fitness_history.append(self.best_fitness)
    return self.best_solution
  def _initialize(self):
    self.pheromonesAsig=np.ones(len(self.asig))
    self.pheromonesAula=np.ones(len(rooms))
    self.pheromonesDia=np.ones(5)
    self.pheromonesHora=np.ones(24)
    self.pheromonesProfe=np.ones(len(instructors))
    self.best_solution=None
    self.best_fitness=float("inf")
    self.pheromone_history=[]
    self.trails_history=[]
    self.best_fitness_history=[]
  def _evaluate(self,solution)->float:
    return evaluate_aco(solution)
  def _construct_solution(self):
    solution = generarHorarioVacio()
    candidates = self.asig.astype(int)
    indexAulas = [i for i in range(len(self.clases))]
    indexHoras = [i for i in range(24)]
    indexProfes = [i for i in range(len(instructors))]
    while True:
        indexDias = [i for i in range(5)]
        if len(candidates) == 0:
            break
        # Elegir asignatura
        pheromonesAsig = self.pheromonesAsig[candidates - 1] ** self.alpha
        heuristicAsig = self._heuristicAsig(candidates) ** self.beta
        totalAsig = np.sum(pheromonesAsig * heuristicAsig)
        if totalAsig==0:
            probabilitiesAsig=[1/len(pheromonesAsig) for i in range(len(pheromonesAsig))]
        else:
            probabilitiesAsig=(pheromonesAsig*heuristicAsig)/totalAsig
        asignatura = np.random.choice(candidates, p=probabilitiesAsig)
        indexAsignatura = classes.index[classes['id'] == asignatura].tolist()
        # Elegir aula
        pheromonesAula = self.pheromonesAula ** self.alpha
        heuristicAula = self._heuristicAula(solution, asignatura) ** self.beta
        totalAula = np.sum(pheromonesAula * heuristicAula)
        if totalAula == 0:
            probabilitiesAula=[1/len(pheromonesAula) for i in range(len(pheromonesAula))]
        else:
            probabilitiesAula = (pheromonesAula * heuristicAula) / totalAula
        aulaElegida = np.random.choice(indexAulas, p=probabilitiesAula)
        # Elegir días y horas
        listDias = []
        listHoras = []
        for i in range(self.diasAsig[indexAsignatura[0]]):
            # Elegir Día
            pheromonesDia = self.pheromonesDia ** self.alpha
            heuristicDia = self._heuristicDia(solution, aulaElegida, listDias, i) ** self.beta
            totalDia = np.sum(pheromonesDia * heuristicDia)
            if totalDia == 0:
                probabilitiesDia=np.array([0.2,0.2,0.2,0.2,0.2])
            else:
              probabilitiesDia = (pheromonesDia * heuristicDia) / totalDia
            diaElegido = np.random.choice(indexDias, p=probabilitiesDia)
            listDias.append(diaElegido)
            # Elegir Hora
            pheromonesHora = self.pheromonesHora ** self.alpha
            heuristicHora = self._heuristicHora(solution, indexAsignatura[0], aulaElegida, diaElegido) ** self.beta
            totalHora = np.sum(pheromonesHora * heuristicHora)
            if totalHora == 0:
              probabilitiesHora=[1/(len(pheromonesHora)-6) for i in range(len(pheromonesHora)-6)]
              probabilitiesHora.extend([0,0,0,0,0,0])
            else:
              probabilitiesHora=(pheromonesHora*heuristicHora)/totalHora
            horaElegida = np.random.choice(indexHoras, p=probabilitiesHora)
            listHoras.append(horaElegida)
        # Elegir profe
        pheromonesProfe = self.pheromonesProfe ** self.alpha
        heuristicProfe = self._heuristicProfe(solution, indexAsignatura) ** self.beta
        totalProfe = np.sum(pheromonesProfe * heuristicProfe)
        # Verificar si totalProfe es cero
        if totalProfe == 0:
            probabilitiesProfe=[1/len(pheromonesProfe) for i in range(len(pheromonesProfe))]
        else:
          probabilitiesProfe = (pheromonesProfe * heuristicProfe) / totalProfe
        profeElegido = np.random.choice(indexProfes, p=probabilitiesProfe)
        # Meter asignatura en solución
        for index, i in enumerate(listDias):
            for j in range(int(self.lengths[indexAsignatura][0]) * 2):
                solution[0][aulaElegida][i][listHoras[index] + j].append(asignatura)
        solution[1][profeElegido].append(asignatura)
        candidates = candidates.tolist()
        candidates.remove(asignatura)
        candidates = np.array(candidates)
    return solution
  def _heuristicAsig(self,candidates:List[int])->np.ndarray:
    return self.lengths[candidates-1]/4
  def _heuristicAula(self,solucion,asignaturaElegida)->np.ndarray:
   arrayHeuristicAula=np.zeros(len(rooms))
   fila_clase=classes.index[classes['id']==asignaturaElegida].tolist()
   listaAulas=self.asignadas[fila_clase[0]]
   if len(listaAulas)==1:
    roomElegida=listaAulas[0]
    fila_rooms=rooms.index[rooms['id']==roomElegida].tolist()
    arrayHeuristicAula[fila_rooms[0]]=1000
   else:
    if len(listaAulas)==0:
      listaAulas=self.clases
    for index,aula in enumerate(listaAulas):
      asigAula=[]
      huecosDia=[]
      for i in range(5):
        numHuecos=0
        for j in range(24):
          if len(solucion[0][index][i][j])==0:
            numHuecos+=1
          else:
            for k in solucion[0][index][i][j]:
              asigAula.append(k)
        huecosDia.append(numHuecos)
      contador=0
      for hueco in huecosDia:
        if hueco>self.lengths[fila_clase[0]]*2:
          contador+=1
      if contador<self.diasAsig[fila_clase[0]]:
        arrayHeuristicAula[index]=0
        break
      else:
        arrayHeuristicAula[index]=(np.mean(huecosDia)/5)
   return arrayHeuristicAula
  def _heuristicDia(self,solucion,indexAulaElegida,listDias,iteracion)->np.ndarray:
    arrayHeuristicDia=np.zeros(5)
    for i in range(5):
      numHuecos=0
      for j in range(24):
        if len(solucion[0][indexAulaElegida][i][j])==0:
          numHuecos+=1
      if iteracion!=0:
        if listDias[iteracion-1]==i:
          arrayHeuristicDia[i]=0
        else:
          arrayHeuristicDia[i]=numHuecos/24
      else:
        arrayHeuristicDia[i]=numHuecos/24
    return arrayHeuristicDia
  def _heuristicHora(self,solution,indexAsignaturaElegida,indexAulaElegida,diaElegido)->np.ndarray:
    arrayHeuristicHora=np.zeros(24)
    for i in range(24):
      if i>24-(self.lengths[indexAsignaturaElegida]*2):
         arrayHeuristicHora[i]=0
      else:
        if len(solution[0][indexAulaElegida][diaElegido][i])>0:
          arrayHeuristicHora[i]=0
        else:
          arrayHeuristicHora[i]=(24-i)/24
    return arrayHeuristicHora
  def _heuristicProfe(self,solucion,indexAsignaturaElegida)->np.ndarray:
    arrayHeuristicProfe=np.zeros(len(instructors))
    pA=self.profesAsig[indexAsignaturaElegida]
    if pA!=0:
      arrayHeuristicProfe[pA-1]=1e10
    else:
      for i in range(solucion[1]):
        numAsig=len(solucion[1][i])
        if numAsig<=5:
          arrayHeuristicProfe[i]=(5-numAsig)/5
        else:
          arrayHeuristicProfe[i]=0
    return arrayHeuristicProfe
  def _update_pheromone(self,trails:List[List[int]],best_fitness):
    evaporation = 1 - self.rho
    self.pheromonesAsig*=evaporation
    self.pheromonesAula*=evaporation
    self.pheromonesDia*=evaporation
    self.pheromonesHora*=evaporation
    self.pheromonesProfe*=evaporation

aco=ScheduleProblem(asignaturas,duraciones,aulas,aulasAsignadas,dias,profesClases)
best_solution=aco.optimize()

def evaluate_aco(solution):
  hard=0
  h1=dosClasesALaVezEnUnAula_Norm_aco(solution)
  h2=profeDosClasesALaVez_aco(solution)
  h3=estudianteDosClasesALaVez_aco(solution)
  hard=0.17*h1+0.17*h2+0.16*h3
  dist,camb,huecos=comprobarMetrosRecorridosDia_CambiosDeClase_NumHuecosEstudiante_Norm_aco(solution)
  fit=hard+0.1*clasesDosDiasSeguidos_Norm_aco(solution)+0.1*numHuecosEnHorario_Norm_aco(solution)+0.1*huecos+0.1*dist+0.1*camb
  return fit

asignaturas=classes["id"].values.astype(int)
duraciones=classes["length"].values.astype(float)
aulas=rooms["id"].values.astype(int)
aulasAsignadas=classes["room_id"].values
dias=classes["days"].values.astype(int)
profesClases=classes["instructor"].values.astype(int)

"""# Constraints ACO

## Hard constraints ACO
"""

def transformarSolucion(solucion):
  transformada=generarVacio()
  for i in range(len(solucion[0])):
    subjects=recogerDatosAula(solucion,i)
    days=["" for i in range(len(subjects))]
    hours=[[] for i in range(len(subjects))]
    for j in range(5):
      for k in range(24):
        if len(solucion[0][i][j][k])>0:
          for q in range(len(solucion[0][i][j][k])):
            indice=subjects.index(solucion[0][i][j][k][q])
            if len(days[indice])<j+1:
              days[indice]+="1"
            if len(hours[indice])<len(days[indice]):
              hours[indice].append(k)
      for w in range(len(days)):
        if len(days[w])<j+1:
          days[w]+="0"
    for y in range(len(subjects)):
      fila_clase=classes.index[classes['id']==subjects[y]].tolist()
      transformada[0][fila_clase[0]][0]=days[y]
      transformada[0][fila_clase[0]][1]=hours[y]
      transformada[1][fila_clase[0]]=aulas[i]
  for profe in solucion[1]:
    for clase in profe:
      index_clase=classes.index[classes['id']==clase].tolist()
      transformada[2][index_clase[0]]=clase
  return transformada

def recogerDatosAula(solucion,i):
  subjects=[]
  for j in range(5):
    for k in range(24):
      if len(solucion[0][i][j][k])>0:
        subjects.extend(solucion[0][i][j][k])
  return subjects

def dosClasesALaVezEnUnAula_aco(solution):
  total=0
  for i in range(len(solution[0])):
    for j in range(5):
      for k in range(24):
        clases=solution[0][i][j][k]
        if(len(clases)>1):
          total+=1
  return total
def dosClasesALaVezEnUnAula_Norm_aco(x):
  totalIncumple=dosClasesALaVezEnUnAula_aco(x)
  if totalIncumple<300:
    return totalIncumple/300
  else:
    return 1
def profeDosClasesALaVez_aco(solution):
 numUnosA=0
 numUnosB=0
 solucionT = transformarSolucion(solution)
 for i, asignaturas in enumerate(solution[1]):
  dias = []
  horas = []
  for asignatura in asignaturas:
   fila = classes[classes["id"] == asignatura].index.tolist()
   dias.append(solucionT[0][fila[0]][0])
   horas.append(solucionT[0][fila[0]][1])
   for a, dia_a in enumerate(dias):
    for b, dia_b in enumerate(dias):
     if a != b:
      for l in range(5):
       if dia_a[l] == dia_b[l] == "1":
        fila_clase1 = classes[classes['id'] == asignaturas[a]].index.tolist()
        fila_clase2 = classes[classes['id'] == asignaturas[b]].index.tolist()
        length1 = classes.loc[fila_clase1, "length"].iloc[0]
        length2 = classes.loc[fila_clase2, "length"].iloc[0]
        horas1 = horas[a][numUnosA]
        horas2 = horas[b][numUnosB]
        if ((horas1 >= horas2) and (horas1 <= (horas2 + length2 * 2))) or ((horas2 >= horas1) and (horas2 <= (horas1 + length1 * 2))):
          return True
       if dia_a[l]=="1":
        numUnosA+=1
       if dia_b[l]=="1":
        numUnosB+=1
      numUnosA=0
      numUnosB=0
 return False
def estudianteDosClasesALaVez_aco(solucion):
  solucionT=transformarSolucion(solucion)
  numUnosA=0
  numUnosB=0
  incumple=False
  i=0
  for index, student in students.iterrows():
    asignaturas=student["classes"]
    dias=[]
    horas=[]
    for asignatura in asignaturas:
      fila=classes.index[classes["id"]==asignatura].tolist()
      dias.append(solucionT[0][fila[0]][0])
      horas.append(solucionT[0][fila[0]][1])
    for a in range(len(dias)):
      asignatura=dias[a]
      for b in range(len(dias)):
        asignatura2=dias[b]
        for l in range(5):
          if a!=b and asignatura[l]==asignatura2[l]=="1":
            fila_clase1=classes.index[classes['id'] == asignaturas[a]].tolist()
            fila_clase2=classes.index[classes['id'] == asignaturas[b]].tolist()
            length1=classes.loc[fila_clase1,"length"].iloc[0]
            length2=classes.loc[fila_clase2,"length"].iloc[0]
            horas1=horas[a][numUnosA]
            horas2=horas[b][numUnosB]
            if ((horas1>=horas2)and(horas1<=(horas2+length2*2)))or((horas2>=horas1)and(horas2<=(horas1+length1*2))):
              incumple=True
              break
          if asignatura[l]=="1":
            numUnosA+=1
          if asignatura2[l]=="1":
            numUnosB+=1
        numUnosA=0
        numUnosB=0
        if incumple:
          break
      if incumple:
        break
    if incumple:
      break
  return incumple

"""## Soft constraints ACO"""

def clasesDosDiasSeguidos_aco(solucion):
  solucionT=transformarSolucion(solucion)
  totalIncumple=0
  for i in range(len(solucionT[0])):
    dias=solucionT[0][i][0]
    seguidos=0
    for j in range(5):
      if dias[j]=="1":
        seguidos+=1
      elif dias[j]=="0":
        seguidos=0
      if seguidos>1:
        totalIncumple+=1
        break
  return totalIncumple
def clasesDosDiasSeguidos_Norm_aco(individual):
  total=clasesDosDiasSeguidos(individual)
  return total/len(classes)

def numHuecosEnHorario_aco(solucion):
  huecosPorAula=[]
  for i in range(len(solucion[0])):
    huecosPorDia=[]
    for j in range(5):
      huecos=0
      hayClase=False
      huecoPotencial=False
      for k in range(24):
        if not hayClase:
          if len(solucion[0][i][j][k])>0:
            hayClase=True
        else:
          if not huecoPotencial:
            if len(solucion[0][i][j][k])==0:
              huecoPotencial=True
          else:
            if len(solucion[0][i][j][k])>0:
              huecos+=1
              hayClase=False
              huecoPotencial=False
      huecosPorDia.append(huecos)
    suma=sum(huecosPorDia)
    huecosPorAula.append(suma)
  sumaTotal=sum(huecosPorAula)
  return sumaTotal/len(huecosPorAula)
def numHuecosEnHorario_Norm_aco(x):
  resultado=numHuecosEnHorario_aco(x)
  if resultado<=5:
    return resultado/5
  else:
    return 1

def comprobarMetrosRecorridosDia_CambiosDeClase_NumHuecosEstudiantes_aco(solucion):
  solucionT=transformarSolucion(solucion)
  mediaDistanciasEstudiantePorSemana=[]
  mediaCambiosEstudiantePorSemana=[]
  mediaHuecosPorEstudiante=[]
  mediaCambios=0
  for index, student in students.iterrows():
    asignaturas=student["classes"]
    distanciasPorDia=[]
    cambiosPorDia=[]
    huecosPorDia=[]
    for j in range(5):
      horas=[]
      duracion=[]
      localizacion=[]
      aulas=[]
      distancia=0
      huecos=0
      for asignatura in asignaturas:
         fila_clase=classes.index[classes['id'] == asignatura].tolist()
         dias=solucionT[0][fila_clase[0]][0]
         if dias[j]=="1":
           subcadena=cadena[:j+1]
           numHoras=subcadena.count("1")
           horas.append(solucionT[0][fila_clase[0]][1][numHoras])
           duracion.append(classes.loc[fila_clase[0]]["length"])
           room=solucionT[1][fila_clase[0]]
           aulas.append(room)
           room_index=rooms.index[rooms["id"]==room].tolist()
           localizacion.append(rooms.loc[room_index]["location"].iloc[0])
      if len(horas)>1:
        ordenado = sorted(zip(horas, localizacion,duracion), key=lambda x: x[0])
        #por cada asignatura en las asignaturas ordenadas por horas
        for k in range(len(ordenado)-1):
          x1, y1 = map(float, ordenado[k][1].split(","))
          x2, y2 = map(float, ordenado[k + 1][1].split(","))
          distancia+=math.sqrt((x2-x1)**2 + (y2-y1)**2)
          if (int(ordenado[k+1][0])-(int(ordenado[k][0])+ordenado[k][2] * 2)) > 1:
           huecos+=1
      distanciasPorDia.append(distancia)
      cambiosPorDia.append(len(set(aulas)))
      huecosPorDia.append(huecos)
    mediaDistanciasEstudiantePorSemana.append(np.mean(distanciasPorDia))
    mediaCambiosEstudiantePorSemana.append(np.mean(cambiosPorDia))
    mediaHuecosPorEstudiante.append(np.mean(huecosPorDia))
  mediaCambios=np.mean(mediaCambiosEstudiantePorSemana)
  mediaDistancia=np.mean(mediaDistanciasEstudiantePorSemana)
  mediaHuecos=np.mean(mediaHuecosPorEstudiante)
  return mediaDistancia,mediaCambios,mediaHuecos
def comprobarMetrosRecorridosDia_CambiosDeClase_NumHuecosEstudiante_Norm_aco(x):
  distancia,cambios,huecos=comprobarMetrosRecorridosDia_CambiosDeClase_NumHuecosEstudiantes_aco(x)
  if distancia<=20:
    a=distancia/20
  else:
    a=1
  if cambios<=3:
    b=cambios/3
  else:
    b=1
  if huecos<=0.05:
    c=0
  elif huecos>=0.1  and huecos<0.15:
    c=0.2
  elif huecos>=0.15  and huecos<0.2:
    c=0.4
  elif huecos>=0.2  and huecos<0.25:
    c=0.6
  elif huecos>=0.25  and huecos<0.3:
    c=0.8
  else:
    c=1
  return a,b,c